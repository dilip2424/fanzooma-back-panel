{"ast":null,"code":"import { isPlatformBrowser } from \"@angular/common\";\nimport { InjectionToken, PLATFORM_ID } from '@angular/core';\nimport * as i0 from \"@angular/core\";\n/* Create a new injection token for injecting the window into a component. */\n\nexport const WINDOW = new InjectionToken('WindowToken');\n/* Define abstract class for obtaining reference to the global window object. */\n\nexport class WindowRef {\n  get nativeWindow() {\n    throw new Error('Not implemented.');\n  }\n\n}\n/* Define class that implements the abstract class and returns the native window object. */\n\nexport let BrowserWindowRef = /*#__PURE__*/(() => {\n  class BrowserWindowRef extends WindowRef {\n    constructor() {\n      super();\n    }\n\n    get nativeWindow() {\n      return window;\n    }\n\n  }\n\n  BrowserWindowRef.ɵfac = function BrowserWindowRef_Factory(t) {\n    return new (t || BrowserWindowRef)();\n  };\n\n  BrowserWindowRef.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: BrowserWindowRef,\n    factory: BrowserWindowRef.ɵfac\n  });\n  /* Create an factory function that returns the native window object. */\n\n  return BrowserWindowRef;\n})();\nexport function windowFactory(browserWindowRef, platformId) {\n  if (isPlatformBrowser(platformId)) {\n    return browserWindowRef.nativeWindow;\n  }\n\n  return new Object();\n}\n/* Create a injectable provider for the WindowRef token that uses the BrowserWindowRef class. */\n\nexport const browserWindowProvider = {\n  provide: WindowRef,\n  useClass: BrowserWindowRef\n};\n/* Create an injectable provider that uses the windowFactory function for returning the native window object. */\n\nexport const windowProvider = {\n  provide: WINDOW,\n  useFactory: windowFactory,\n  deps: [WindowRef, PLATFORM_ID]\n};\n/* Create an array of providers. */\n\nexport const WINDOW_PROVIDERS = [browserWindowProvider, windowProvider];","map":null,"metadata":{},"sourceType":"module"}